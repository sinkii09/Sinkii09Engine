using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEditor;

namespace Sinkii09.Engine.Editor.InputSystem
{
    /// <summary>
    /// Generates high-performance delegate cache code from InputActions analysis
    /// </summary>
    public class InputActionCodeGenerator
    {
        private const string GeneratedFileHeader = @"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was auto-generated by InputActionCodeGenerator
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------";

        private const string OutputPath = "Assets/Engine/Runtime/Scripts/Core/Services/Implemented/InputService/Generated/InputActionMappings.generated.cs";

        /// <summary>
        /// Generates the delegate cache code from action information
        /// </summary>
        /// <param name="actionsInfo">Information about discovered input actions</param>
        public void GenerateDelegateCache(InputActionsInfo actionsInfo)
        {
            if (actionsInfo == null || !actionsInfo.ActionMaps.Any())
            {
                Debug.LogError("[InputActionCodeGenerator] No action maps found to generate code for.");
                return;
            }

            Debug.Log($"[InputActionCodeGenerator] Generating code for {actionsInfo.ActionMaps.Count} action maps with {actionsInfo.AllActions.Count()} total actions.");

            var code = new StringBuilder();
            
            // Add header
            code.AppendLine(GeneratedFileHeader);
            code.AppendLine();

            // Add using statements
            GenerateUsingStatements(code);
            code.AppendLine();

            // Add namespace
            code.AppendLine("namespace Sinkii09.Engine.Services");
            code.AppendLine("{");

            // Generate enums for each action map
            foreach (var actionMap in actionsInfo.ActionMaps)
            {
                GenerateActionEnum(code, actionMap);
                code.AppendLine();
            }

            // Generate the main delegate cache class
            GenerateDelegateCacheClass(code, actionsInfo);

            // Close namespace
            code.AppendLine("}");

            // Write to file
            WriteGeneratedFile(code.ToString());

            Debug.Log($"[InputActionCodeGenerator] Successfully generated code at: {OutputPath}");
        }

        /// <summary>
        /// Generates using statements for the generated code
        /// </summary>
        private void GenerateUsingStatements(StringBuilder code)
        {
            code.AppendLine("using System;");
            code.AppendLine("using System.Collections.Generic;");
            code.AppendLine("using UnityEngine;");
            code.AppendLine("using UnityEngine.InputSystem;");
        }

        /// <summary>
        /// Generates an enum for a specific action map
        /// </summary>
        private void GenerateActionEnum(StringBuilder code, ActionMapInfo actionMap)
        {
            code.AppendLine($"    /// <summary>");
            code.AppendLine($"    /// Auto-generated enum for {actionMap.Name} input actions");
            code.AppendLine($"    /// </summary>");
            code.AppendLine($"    public enum {actionMap.Name}Action");
            code.AppendLine("    {");

            for (int i = 0; i < actionMap.Actions.Count; i++)
            {
                var action = actionMap.Actions[i];
                code.AppendLine($"        {action.Name} = {i},");
            }

            code.AppendLine("    }");
        }

        /// <summary>
        /// Generates the main delegate cache class
        /// </summary>
        private void GenerateDelegateCacheClass(StringBuilder code, InputActionsInfo actionsInfo)
        {
            code.AppendLine("    /// <summary>");
            code.AppendLine("    /// Auto-generated high-performance delegate cache for input actions");
            code.AppendLine("    /// </summary>");
            code.AppendLine("    public static class InputActionMappings");
            code.AppendLine("    {");

            // Generate private fields
            GeneratePrivateFields(code, actionsInfo);
            code.AppendLine();

            // Generate delegate dictionaries
            GenerateDelegateDictionaries(code, actionsInfo);
            code.AppendLine();

            // Generate initialization method
            GenerateInitializationMethod(code, actionsInfo);
            code.AppendLine();

            // Generate public API methods
            GeneratePublicApiMethods(code, actionsInfo);

            code.AppendLine("    }");
        }

        /// <summary>
        /// Generates private fields for the delegate cache
        /// </summary>
        private void GeneratePrivateFields(StringBuilder code, InputActionsInfo actionsInfo)
        {
            code.AppendLine("        private static InputSystem_Actions _inputActions;");
            code.AppendLine("        private static bool _isInitialized = false;");
            code.AppendLine();
            
            // Generate event declarations for each action map
            foreach (var actionMap in actionsInfo.ActionMaps)
            {
                code.AppendLine($"        /// <summary>");
                code.AppendLine($"        /// Event triggered when any {actionMap.Name} action state changes");
                code.AppendLine($"        /// </summary>");
                code.AppendLine($"        public static event Action<{actionMap.Name}Action, UnityEngine.InputSystem.InputActionPhase> On{actionMap.Name}ActionTriggered;");
            }
        }

        /// <summary>
        /// Generates delegate dictionaries for each action map and type
        /// </summary>
        private void GenerateDelegateDictionaries(StringBuilder code, InputActionsInfo actionsInfo)
        {
            foreach (var actionMap in actionsInfo.ActionMaps)
            {
                code.AppendLine($"        // {actionMap.Name} Action Delegates");
                code.AppendLine($"        private static readonly Dictionary<{actionMap.Name}Action, Func<bool>> {actionMap.Name}PressedDelegates = new Dictionary<{actionMap.Name}Action, Func<bool>>();");
                code.AppendLine($"        private static readonly Dictionary<{actionMap.Name}Action, Func<bool>> {actionMap.Name}TriggeredDelegates = new Dictionary<{actionMap.Name}Action, Func<bool>>();");
                code.AppendLine($"        private static readonly Dictionary<{actionMap.Name}Action, Func<bool>> {actionMap.Name}ReleasedDelegates = new Dictionary<{actionMap.Name}Action, Func<bool>>();");
                
                // Type-specific delegates based on expected control types
                var hasVector2Actions = actionMap.Actions.Any(a => a.ExpectedControlType == ExpectedControlType.Vector2);
                var hasVector3Actions = actionMap.Actions.Any(a => a.ExpectedControlType == ExpectedControlType.Vector3);
                var hasQuaternionActions = actionMap.Actions.Any(a => a.ExpectedControlType == ExpectedControlType.Quaternion);
                var hasFloatActions = actionMap.Actions.Any(a => a.ExpectedControlType == ExpectedControlType.Float);

                if (hasVector2Actions)
                    code.AppendLine($"        private static readonly Dictionary<{actionMap.Name}Action, Func<Vector2>> {actionMap.Name}Vector2Delegates = new Dictionary<{actionMap.Name}Action, Func<Vector2>>();");
                
                if (hasVector3Actions)
                    code.AppendLine($"        private static readonly Dictionary<{actionMap.Name}Action, Func<Vector3>> {actionMap.Name}Vector3Delegates = new Dictionary<{actionMap.Name}Action, Func<Vector3>>();");
                
                if (hasQuaternionActions)
                    code.AppendLine($"        private static readonly Dictionary<{actionMap.Name}Action, Func<Quaternion>> {actionMap.Name}QuaternionDelegates = new Dictionary<{actionMap.Name}Action, Func<Quaternion>>();");
                
                if (hasFloatActions)
                    code.AppendLine($"        private static readonly Dictionary<{actionMap.Name}Action, Func<float>> {actionMap.Name}FloatDelegates = new Dictionary<{actionMap.Name}Action, Func<float>>();");

                code.AppendLine();
            }
        }

        /// <summary>
        /// Generates the initialization method that maps enums to Unity's action references
        /// </summary>
        private void GenerateInitializationMethod(StringBuilder code, InputActionsInfo actionsInfo)
        {
            code.AppendLine("        /// <summary>");
            code.AppendLine("        /// Initializes the delegate cache with InputSystem_Actions instance");
            code.AppendLine("        /// </summary>");
            code.AppendLine("        public static void Initialize(InputSystem_Actions inputActions)");
            code.AppendLine("        {");
            code.AppendLine("            // Clean up any existing subscriptions first");
            code.AppendLine("            if (_isInitialized)");
            code.AppendLine("            {");
            code.AppendLine("                Cleanup();");
            code.AppendLine("            }");
            code.AppendLine();
            code.AppendLine("            _inputActions = inputActions ?? throw new ArgumentNullException(nameof(inputActions));");
            code.AppendLine();

            foreach (var actionMap in actionsInfo.ActionMaps)
            {
                code.AppendLine($"            // Initialize {actionMap.Name} delegates");
                
                foreach (var action in actionMap.Actions)
                {
                    string actionReference = $"_inputActions.{actionMap.Name}.{action.PropertyName}";
                    
                    // Basic button delegates
                    code.AppendLine($"            {actionMap.Name}PressedDelegates[{actionMap.Name}Action.{action.Name}] = () => {actionReference}.IsPressed();");
                    code.AppendLine($"            {actionMap.Name}TriggeredDelegates[{actionMap.Name}Action.{action.Name}] = () => {actionReference}.WasPressedThisFrame();");
                    code.AppendLine($"            {actionMap.Name}ReleasedDelegates[{actionMap.Name}Action.{action.Name}] = () => {actionReference}.WasReleasedThisFrame();");

                    // Type-specific delegates
                    switch (action.ExpectedControlType)
                    {
                        case ExpectedControlType.Vector2:
                            code.AppendLine($"            {actionMap.Name}Vector2Delegates[{actionMap.Name}Action.{action.Name}] = () => {actionReference}.ReadValue<Vector2>();");
                            break;
                        case ExpectedControlType.Vector3:
                            code.AppendLine($"            {actionMap.Name}Vector3Delegates[{actionMap.Name}Action.{action.Name}] = () => {actionReference}.ReadValue<Vector3>();");
                            break;
                        case ExpectedControlType.Quaternion:
                            code.AppendLine($"            {actionMap.Name}QuaternionDelegates[{actionMap.Name}Action.{action.Name}] = () => {actionReference}.ReadValue<Quaternion>();");
                            break;
                        case ExpectedControlType.Float:
                            code.AppendLine($"            {actionMap.Name}FloatDelegates[{actionMap.Name}Action.{action.Name}] = () => {actionReference}.ReadValue<float>();");
                            break;
                    }
                }
                code.AppendLine();
            }

            // Generate event subscriptions for each action map
            foreach (var actionMap in actionsInfo.ActionMaps)
            {
                code.AppendLine($"            // Setup {actionMap.Name} action events");
                
                foreach (var action in actionMap.Actions)
                {
                    string actionReference = $"_inputActions.{actionMap.Name}.{action.PropertyName}";
                    string eventHandler = $"On{actionMap.Name}ActionEvent";
                    
                    code.AppendLine($"            {actionReference}.started += {eventHandler};");
                    code.AppendLine($"            {actionReference}.performed += {eventHandler};");
                    code.AppendLine($"            {actionReference}.canceled += {eventHandler};");
                }
                code.AppendLine();
            }

            code.AppendLine("            _isInitialized = true;");
            code.AppendLine("            Debug.Log($\"[InputActionMappings] Initialized delegate cache with {_inputActions.GetType().Name}\");");
            code.AppendLine("        }");
        }

        /// <summary>
        /// Generates public API methods for accessing actions
        /// </summary>
        private void GeneratePublicApiMethods(StringBuilder code, InputActionsInfo actionsInfo)
        {
            foreach (var actionMap in actionsInfo.ActionMaps)
            {
                code.AppendLine($"        #region {actionMap.Name} Action Methods");
                code.AppendLine();

                // Basic button methods
                code.AppendLine($"        public static bool IsActionPressed({actionMap.Name}Action action)");
                code.AppendLine("        {");
                code.AppendLine("            EnsureInitialized();");
                code.AppendLine($"            return {actionMap.Name}PressedDelegates[action]();");
                code.AppendLine("        }");
                code.AppendLine();

                code.AppendLine($"        public static bool IsActionTriggered({actionMap.Name}Action action)");
                code.AppendLine("        {");
                code.AppendLine("            EnsureInitialized();");
                code.AppendLine($"            return {actionMap.Name}TriggeredDelegates[action]();");
                code.AppendLine("        }");
                code.AppendLine();

                code.AppendLine($"        public static bool IsActionReleased({actionMap.Name}Action action)");
                code.AppendLine("        {");
                code.AppendLine("            EnsureInitialized();");
                code.AppendLine($"            return {actionMap.Name}ReleasedDelegates[action]();");
                code.AppendLine("        }");
                code.AppendLine();

                // Type-specific methods
                if (actionMap.Actions.Any(a => a.ExpectedControlType == ExpectedControlType.Vector2))
                {
                    code.AppendLine($"        public static Vector2 GetVector2Value({actionMap.Name}Action action)");
                    code.AppendLine("        {");
                    code.AppendLine("            EnsureInitialized();");
                    code.AppendLine($"            return {actionMap.Name}Vector2Delegates.TryGetValue(action, out var del) ? del() : Vector2.zero;");
                    code.AppendLine("        }");
                    code.AppendLine();
                }

                if (actionMap.Actions.Any(a => a.ExpectedControlType == ExpectedControlType.Float))
                {
                    code.AppendLine($"        public static float GetFloatValue({actionMap.Name}Action action)");
                    code.AppendLine("        {");
                    code.AppendLine("            EnsureInitialized();");
                    code.AppendLine($"            return {actionMap.Name}FloatDelegates.TryGetValue(action, out var del) ? del() : 0f;");
                    code.AppendLine("        }");
                    code.AppendLine();
                }

                code.AppendLine($"        #endregion");
                code.AppendLine();
            }

            // Utility methods
            code.AppendLine("        private static void EnsureInitialized()");
            code.AppendLine("        {");
            code.AppendLine("            if (!_isInitialized)");
            code.AppendLine("                throw new InvalidOperationException(\"InputActionMappings must be initialized before use. Call Initialize() first.\");");
            code.AppendLine("        }");
            code.AppendLine();

            // Generate Cleanup method
            GenerateCleanupMethod(code, actionsInfo);
        }

        /// <summary>
        /// Generates the Cleanup method for proper event unsubscription
        /// </summary>
        private void GenerateCleanupMethod(StringBuilder code, InputActionsInfo actionsInfo)
        {
            code.AppendLine("        /// <summary>");
            code.AppendLine("        /// Properly cleans up all event subscriptions and resets state");
            code.AppendLine("        /// </summary>");
            code.AppendLine("        public static void Cleanup()");
            code.AppendLine("        {");
            code.AppendLine("            if (!_isInitialized || _inputActions == null)");
            code.AppendLine("            {");
            code.AppendLine("                Debug.Log(\"[InputActionMappings] Cleanup called but not initialized, skipping.\");");
            code.AppendLine("                return;");
            code.AppendLine("            }");
            code.AppendLine();
            code.AppendLine("            Debug.Log(\"[InputActionMappings] Cleaning up event subscriptions...\");");
            code.AppendLine();

            // Generate unsubscriptions for each action map
            foreach (var actionMap in actionsInfo.ActionMaps)
            {
                code.AppendLine($"            // Unsubscribe from {actionMap.Name} action events");
                
                foreach (var action in actionMap.Actions)
                {
                    string actionReference = $"_inputActions.{actionMap.Name}.{action.PropertyName}";
                    string eventHandler = $"On{actionMap.Name}ActionEvent";
                    
                    code.AppendLine($"            {actionReference}.started -= {eventHandler};");
                    code.AppendLine($"            {actionReference}.performed -= {eventHandler};");
                    code.AppendLine($"            {actionReference}.canceled -= {eventHandler};");
                }
                code.AppendLine();
            }

            code.AppendLine("            // Clear static events to prevent memory leaks");
            foreach (var actionMap in actionsInfo.ActionMaps)
            {
                code.AppendLine($"            On{actionMap.Name}ActionTriggered = null;");
            }
            code.AppendLine();

            code.AppendLine("            // Reset state");
            code.AppendLine("            _inputActions = null;");
            code.AppendLine("            _isInitialized = false;");
            code.AppendLine();
            code.AppendLine("            Debug.Log(\"[InputActionMappings] Cleanup completed successfully.\");");
            code.AppendLine("        }");
            
            // Generate event handler methods
            GenerateEventHandlerMethods(code, actionsInfo);
        }

        /// <summary>
        /// Generates dedicated event handler methods for each action map
        /// </summary>
        private void GenerateEventHandlerMethods(StringBuilder code, InputActionsInfo actionsInfo)
        {
            foreach (var actionMap in actionsInfo.ActionMaps)
            {
                code.AppendLine();
                code.AppendLine($"        private static void On{actionMap.Name}ActionEvent(InputAction.CallbackContext ctx)");
                code.AppendLine("        {");
                code.AppendLine("            try");
                code.AppendLine("            {");
                code.AppendLine("                var actionName = ctx.action.name;");
                code.AppendLine($"                var action = Get{actionMap.Name}ActionFromName(actionName);");
                code.AppendLine($"                On{actionMap.Name}ActionTriggered?.Invoke(action, ctx.phase);");
                code.AppendLine("            }");
                code.AppendLine("            catch (Exception ex)");
                code.AppendLine("            {");
                code.AppendLine($"                Debug.LogError($\"[InputActionMappings] Error in {actionMap.Name.ToLower()} action event: {{ex.Message}}\");");
                code.AppendLine("            }");
                code.AppendLine("        }");
                code.AppendLine();
                
                // Generate action name mapping method
                code.AppendLine($"        private static {actionMap.Name}Action Get{actionMap.Name}ActionFromName(string actionName)");
                code.AppendLine("        {");
                code.AppendLine("            return actionName switch");
                code.AppendLine("            {");
                
                foreach (var action in actionMap.Actions)
                {
                    code.AppendLine($"                \"{action.PropertyName}\" => {actionMap.Name}Action.{action.Name},");
                }
                
                code.AppendLine($"                _ => throw new ArgumentException($\"Unknown {actionMap.Name.ToLower()} action: {{actionName}}\")");
                code.AppendLine("            };");
                code.AppendLine("        }");
            }
        }

        /// <summary>
        /// Writes the generated code to the output file
        /// </summary>
        private void WriteGeneratedFile(string code)
        {
            try
            {
                // Ensure directory exists
                string directory = Path.GetDirectoryName(OutputPath);
                if (!Directory.Exists(directory))
                {
                    Directory.CreateDirectory(directory);
                }

                // Write the file
                File.WriteAllText(OutputPath, code);

                // Refresh Unity's AssetDatabase
                AssetDatabase.Refresh();

                Debug.Log($"[InputActionCodeGenerator] Generated file written to: {OutputPath}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[InputActionCodeGenerator] Failed to write generated file: {ex.Message}");
                throw;
            }
        }
    }
}